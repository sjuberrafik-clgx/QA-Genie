/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 * AUTOMATION SCRIPT GENERATOR
 * ═══════════════════════════════════════════════════════════════════════════════════════
 * 
 * Generates Playwright automation scripts from recorded actions
 * Uses the unified tool results to create production-ready test code
 * 
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

import { ToolRecommendationEngine } from '../router/intelligent-router.js';
import { SelectorEngine } from './selector-engine.js';

/**
 * Script Generator for creating Playwright test scripts
 */
export class ScriptGenerator {
    constructor(options = {}) {
        this.options = {
            framework: options.framework || 'playwright', // 'playwright', 'cypress', 'puppeteer'
            language: options.language || 'javascript', // 'javascript', 'typescript'
            includeComments: options.includeComments ?? true,
            includeAssertions: options.includeAssertions ?? true,
            retryOnFailure: options.retryOnFailure ?? true,
            ...options,
        };

        // Configurable import paths — defaults match established framework pattern
        // Can be overridden via options.imports or options.frameworkMode
        const frameworkMode = options.frameworkMode || 'full';
        this.imports = options.imports || (frameworkMode === 'basic' ? {
            config: null,
            poManager: null,
            testData: null,
            importPrefix: ''
        } : {
            config: options.configImport || '../../config/config',
            poManager: options.poManagerImport || '../../pageobjects/POmanager',
            testData: options.testDataImport || '../../test-data/testData',
            importPrefix: options.importPrefix || '../../'
        });

        this.recordedActions = [];
        this.snapshotData = null;
        this.pageUrl = null;
    }

    /**
     * Record an action for script generation
     */
    recordAction(action) {
        this.recordedActions.push({
            ...action,
            timestamp: Date.now(),
        });
    }

    /**
     * Set the current snapshot data
     */
    setSnapshot(snapshot) {
        this.snapshotData = snapshot;
    }

    /**
     * Set the current page URL
     */
    setPageUrl(url) {
        this.pageUrl = url;
    }

    /**
     * Generate script from recorded actions
     */
    generateScript(testName = 'Generated Test') {
        const lines = [];

        // Add imports, describe block, beforeAll/afterAll
        lines.push(...this.generateHeader(testName));

        // Wrap recorded actions in a test block
        lines.push(`  test('${testName}', async () => {`);

        // Add test body (actions)
        lines.push(...this.generateTestBody());

        // Close test block
        lines.push('  });');

        // Add footer (closes describe)
        lines.push(...this.generateFooter());

        return lines.join('\n');
    }

    /**
     * Generate script header with imports
     * Uses CommonJS require + launchBrowser() + POmanager pattern
     * to match the framework conventions in tests/specs/
     */
    generateHeader(testName) {
        const lines = [];

        // Always use CommonJS require() — project standard is JavaScript, not TypeScript
        lines.push("const { test, expect } = require('@playwright/test');");
        if (this.imports.config) {
            lines.push(`const { launchBrowser } = require('${this.imports.config}');`);
        }
        if (this.imports.poManager) {
            lines.push(`const POmanager = require('${this.imports.poManager}');`);
        }
        if (this.imports.testData) {
            lines.push(`const { userTokens } = require('${this.imports.testData}');`);
        }

        lines.push('');

        if (this.options.includeComments) {
            lines.push('/**');
            lines.push(` * ${testName}`);
            lines.push(` * Generated: ${new Date().toISOString()}`);
            lines.push(' * Generated by Unified Automation MCP Server');
            lines.push(' */');
        }

        lines.push('');
        lines.push(`test.describe.serial('${testName}', () => {`);

        if (this.imports.config) {
            // Full framework mode: launchBrowser + POmanager pattern
            lines.push('  let browser, context, page;');
            lines.push('  let Pomanager, generalFunctions, homePage;');
            lines.push('');
            lines.push('  test.beforeAll(async () => {');
            lines.push('    const launched = await launchBrowser();');
            lines.push('    browser = launched.browser;');
            lines.push('    context = launched.context;');
            lines.push('    page = launched.page;');
            lines.push('');
            lines.push('    Pomanager = new POmanager(page);');
            lines.push('    generalFunctions = Pomanager.generalFunctions();');
            lines.push('    homePage = Pomanager.homePage();');

            if (this.pageUrl) {
                lines.push('');
                lines.push(`    await generalFunctions.openOneHome(userTokens.canopy);`);
            }

            lines.push('  });');
            lines.push('');
            lines.push('  test.afterAll(async () => {');
            lines.push("    if (page && !page.isClosed()) await page.close();");
            lines.push('    if (context) await context.close();');
            lines.push('    if (browser) await browser.close();');
            lines.push('  });');
        } else {
            // Basic mode: standalone Playwright
            lines.push('  let page;');
            lines.push('');
            lines.push('  test.beforeAll(async ({ browser }) => {');
            lines.push('    page = await browser.newPage();');

            if (this.pageUrl) {
                lines.push(`    await page.goto('${this.pageUrl}');`);
            }

            lines.push('  });');
            lines.push('');
            lines.push('  test.afterAll(async () => {');
            lines.push("    if (page && !page.isClosed()) await page.close();");
            lines.push('  });');
        }

        if (this.options.retryOnFailure) {
            lines.push('');
            lines.push('  // Configure retries for flaky steps');
            lines.push('  test.setTimeout(60000);');
        }

        lines.push('');

        return lines;
    }

    /**
     * Generate test body from recorded actions
     */
    generateTestBody() {
        const lines = [];

        for (const action of this.recordedActions) {
            const code = this.actionToCode(action);
            if (code) {
                if (this.options.includeComments && action.description) {
                    lines.push(`  // ${action.description}`);
                }
                lines.push(`  ${code}`);
                lines.push('');
            }
        }

        return lines;
    }

    /**
     * Convert a single action to code
     */
    actionToCode(action) {
        const { tool, args, result } = action;

        switch (tool) {
            case 'unified_navigate':
                return `await page.goto('${args.url}');`;

            case 'unified_click':
                return this.generateClickCode(args);

            case 'unified_type':
                return this.generateTypeCode(args);

            case 'unified_hover':
                return this.generateHoverCode(args);

            case 'unified_select_option':
                return this.generateSelectCode(args);

            case 'unified_fill_form':
                return this.generateFormCode(args);

            case 'unified_wait_for':
                return this.generateWaitCode(args);

            case 'unified_press_key':
                return `await page.keyboard.press('${args.key}');`;

            case 'unified_screenshot':
                return `await page.screenshot({ path: '${args.filename || 'screenshot.png'}' });`;

            case 'unified_verify_text_visible':
                return `await expect(page.getByText('${args.text}')).toBeVisible();`;

            case 'unified_verify_element_visible':
                return `await expect(page.getByRole('${args.role}', { name: '${args.accessibleName}' })).toBeVisible();`;

            case 'unified_handle_dialog':
                return this.generateDialogCode(args);

            case 'unified_tabs':
                return this.generateTabsCode(args);

            default:
                return `// Unsupported action: ${tool}`;
        }
    }

    /**
     * Generate click code with locator
     */
    generateClickCode(args) {
        const locator = this.refToLocator(args.ref, args.element);

        if (args.doubleClick) {
            return `await ${locator}.dblclick();`;
        }

        if (args.button && args.button !== 'left') {
            return `await ${locator}.click({ button: '${args.button}' });`;
        }

        return `await ${locator}.click();`;
    }

    /**
     * Generate type code with locator
     */
    generateTypeCode(args) {
        const locator = this.refToLocator(args.ref, args.element);

        if (args.slowly) {
            return `await ${locator}.pressSequentially('${args.text}');`;
        }

        let code = `await ${locator}.fill('${args.text}');`;

        if (args.submit) {
            code += `\n  await ${locator}.press('Enter');`;
        }

        return code;
    }

    /**
     * Generate hover code
     */
    generateHoverCode(args) {
        const locator = this.refToLocator(args.ref, args.element);
        return `await ${locator}.hover();`;
    }

    /**
     * Generate select code
     */
    generateSelectCode(args) {
        const locator = this.refToLocator(args.ref, args.element);
        const values = args.values.map(v => `'${v}'`).join(', ');
        return `await ${locator}.selectOption([${values}]);`;
    }

    /**
     * Generate form filling code
     */
    generateFormCode(args) {
        const lines = [];

        for (const field of args.fields) {
            const locator = this.refToLocator(field.ref);
            lines.push(`await ${locator}.fill('${field.value}');`);
        }

        return lines.join('\n  ');
    }

    /**
     * Generate wait code
     */
    generateWaitCode(args) {
        if (args.time) {
            return `await page.waitForTimeout(${args.time * 1000});`;
        }

        if (args.text) {
            return `await page.getByText('${args.text}').waitFor();`;
        }

        if (args.textGone) {
            return `await page.getByText('${args.textGone}').waitFor({ state: 'hidden' });`;
        }

        return '// Wait condition not specified';
    }

    /**
     * Generate dialog handling code
     */
    generateDialogCode(args) {
        if (args.accept) {
            if (args.promptText) {
                return `page.on('dialog', dialog => dialog.accept('${args.promptText}'));`;
            }
            return `page.on('dialog', dialog => dialog.accept());`;
        }
        return `page.on('dialog', dialog => dialog.dismiss());`;
    }

    /**
     * Generate tabs management code
     */
    generateTabsCode(args) {
        switch (args.action) {
            case 'create':
                return 'const newPage = await context.newPage();';
            case 'close':
                return args.index !== undefined
                    ? `await pages[${args.index}].close();`
                    : 'await page.close();';
            case 'select':
                return `await pages[${args.index}].bringToFront();`;
            default:
                return 'const pages = context.pages();';
        }
    }

    /**
     * Convert ref to Playwright locator.
     * Delegates to SelectorEngine — uses pre-validated selectors from snapshot data.
     */
    refToLocator(ref, description = '') {
        // If we have snapshot data, try to find the element and use SelectorEngine
        if (this.snapshotData && ref) {
            const element = this.findElementInSnapshot(ref);
            if (element) {
                return this.elementToLocator(element);
            }
        }

        // Fallback to description-based locator
        if (description) {
            if (description.toLowerCase().includes('button')) {
                return `page.getByRole('button', { name: '${description}' })`;
            }
            if (description.toLowerCase().includes('link')) {
                return `page.getByRole('link', { name: '${description}' })`;
            }
            if (description.toLowerCase().includes('input') || description.toLowerCase().includes('field')) {
                return `page.getByLabel('${description}')`;
            }
            return `page.getByText('${description}')`;
        }

        // Last resort
        return `page.getByText('${ref}')`;
    }

    /**
     * Find element in snapshot data by ref.
     * Now actually implemented — searches through snapshot elements.
     */
    findElementInSnapshot(ref) {
        if (!this.snapshotData) return null;

        // Snapshot data can be in multiple formats
        // Format 1: Array of elements directly
        if (Array.isArray(this.snapshotData)) {
            return this.snapshotData.find(el => el.ref === ref) || null;
        }

        // Format 2: { elements: [...] }
        if (this.snapshotData.elements && Array.isArray(this.snapshotData.elements)) {
            return this.snapshotData.elements.find(el => el.ref === ref) || null;
        }

        // Format 3: { snapshots: [{ elements: [...] }] }  (exploration data format)
        if (this.snapshotData.snapshots && Array.isArray(this.snapshotData.snapshots)) {
            for (const snap of this.snapshotData.snapshots) {
                if (snap.elements) {
                    const found = snap.elements.find(el => el.ref === ref);
                    if (found) return found;
                }
            }
        }

        return null;
    }

    /**
     * Convert snapshot element to Playwright locator.
     * Uses SelectorEngine if the element has pre-computed selector data;
     * otherwise generates candidates on the fly.
     */
    elementToLocator(element) {
        // If element already has selector data from SelectorEngine (enriched snapshot)
        if (element.selector && element.selector.primary) {
            return element.selector.primary;
        }

        // Otherwise use SelectorEngine to compute it now
        const result = SelectorEngine.generateUniqueSelector(element, {});
        return result.primary;
    }

    /**
     * Generate script footer — closes the test.describe.serial block
     */
    generateFooter() {
        const lines = [];

        lines.push('});'); // Close test.describe.serial
        lines.push('');

        return lines;
    }

    /**
     * Generate a complete test file with multiple tests
     * Uses launchBrowser() + POmanager pattern to match framework conventions
     */
    generateTestFile(tests, suiteName = 'Generated Test Suite') {
        const lines = [];

        // Imports — always CommonJS (project standard)
        lines.push("const { test, expect } = require('@playwright/test');");
        if (this.imports.config) {
            lines.push(`const { launchBrowser } = require('${this.imports.config}');`);
        }
        if (this.imports.poManager) {
            lines.push(`const POmanager = require('${this.imports.poManager}');`);
        }
        if (this.imports.testData) {
            lines.push(`const { userTokens } = require('${this.imports.testData}');`);
        }

        lines.push('');
        lines.push(`test.describe.serial('${suiteName}', () => {`);

        if (this.imports.config) {
            // Full framework mode: launchBrowser + POmanager pattern
            lines.push('  let browser, context, page;');
            lines.push('  let Pomanager, generalFunctions, homePage;');
            lines.push('');
            lines.push('  test.beforeAll(async () => {');
            lines.push('    const launched = await launchBrowser();');
            lines.push('    browser = launched.browser;');
            lines.push('    context = launched.context;');
            lines.push('    page = launched.page;');
            lines.push('');
            lines.push('    Pomanager = new POmanager(page);');
            lines.push('    generalFunctions = Pomanager.generalFunctions();');
            lines.push('    homePage = Pomanager.homePage();');

            if (this.pageUrl) {
                lines.push('');
                lines.push('    await generalFunctions.openOneHome(userTokens.canopy);');
            }

            lines.push('  });');
            lines.push('');
            lines.push('  test.afterAll(async () => {');
            lines.push("    if (page && !page.isClosed()) await page.close();");
            lines.push('    if (context) await context.close();');
            lines.push('    if (browser) await browser.close();');
            lines.push('  });');
        } else {
            // Basic mode: standalone Playwright
            lines.push('  let page;');
            lines.push('');
            lines.push('  test.beforeAll(async ({ browser }) => {');
            lines.push('    page = await browser.newPage();');

            if (this.pageUrl) {
                lines.push(`    await page.goto('${this.pageUrl}');`);
            }

            lines.push('  });');
            lines.push('');
            lines.push('  test.afterAll(async () => {');
            lines.push("    if (page && !page.isClosed()) await page.close();");
            lines.push('  });');
        }
        lines.push('');

        // Add each test
        for (const t of tests) {
            lines.push(`  test('${t.name}', async () => {`);
            for (const action of t.actions) {
                const code = this.actionToCode(action);
                if (code) {
                    lines.push(`    ${code}`);
                }
            }
            lines.push('  });');
            lines.push('');
        }

        lines.push('});');

        return lines.join('\n');
    }

    /**
     * Clear recorded actions
     */
    clear() {
        this.recordedActions = [];
        this.snapshotData = null;
        this.pageUrl = null;
    }
}

/**
 * Helper to generate locators from element descriptions.
 * Delegates to SelectorEngine for consistent scoring and selection.
 */
export class LocatorGenerator {
    /**
     * Generate the best locator strategy for an element.
     * Uses SelectorEngine.generateUniqueSelector for scoring.
     */
    static generateLocator(element) {
        // If element already has pre-computed selector data
        if (element.selector && element.selector.primary) {
            return {
                type: element.selector.strategy || 'pre-computed',
                code: element.selector.primary,
                priority: 1,
                stabilityScore: element.selector.stabilityScore || 10,
                isUnique: element.selector.isUnique ?? true,
            };
        }

        // Otherwise compute via SelectorEngine
        const result = SelectorEngine.generateUniqueSelector(element, {});
        return {
            type: result.strategy,
            code: result.primary,
            priority: 1,
            stabilityScore: result.stabilityScore,
            isUnique: result.isUnique,
            fallback: result.fallback,
        };
    }
}
